## 1. 词法分析

* 物理行 VS 逻辑行

    * 物理行：程序员所写代码的所在行（以一个行终止序列结束的字符序列）

    * 逻辑行：源代码经过预编译后，代码所在的那一行

    * Python 默认 一个物理行 对应 一个逻辑行，但是实际使用时并非如此

    * 多个物理行 对应 一个逻辑行 (物理行末尾用 \ 拼接)

        ```
        info = "I \
                am \
                Syd"
        print(info)
        ```

    * 一个物理行 对应 多个逻辑行 ((逻辑行之间用 ; 拼接))

        ```
        info = "info"; print(info)
        ```


* 显示行拼接 VS 隐式行拼接

    * 两个或更多个物理行可使用反斜杠字符 ( \ ) 拼接为一个逻辑行，以反斜杠结尾的物理行**不能出现注释**

        ```
        info = "I \     # ...   （Error！不能出现注释）
                am \
                Syd"
            print(info)
        ```

    * 圆括号、方括号或花括号以内的表达式允许分成多个物理行，**无需使用反斜杠**，可以出现注释

        ```
        info = ["I",    # ...
                "am",
                "Syd"]
        ```

* 缩进

    * Python 解释器通过栈记录代码的缩进信息

    * 在开始读取文件之前，0（表示缩进级别为0，无缩进）会被首先压入栈中。然后从文件开头到末尾，依次读取每行逻辑代码，每行逻辑代码的缩进级别都会和栈顶值进行比较，如果相等，那么什么都不会发生；如果比栈顶值大的话，那么该行逻辑代码的**缩进级别**就会被压入栈中，同时会生成一个缩进标记（INDENT TOKEN）;如果比栈顶值小的话，那么栈中所有比该行逻辑代码缩进级别大的值都会从栈中移除，并且还会生成一个扩展标记（DEDENT TOKEN）。

* \_\* VS  \_\_\*\_\_ VS \_\_\*

    * \_\*：不会被 from module import * 导入

    * \_\_\*\_\_：系统定义的名称

    * \_\_\*：类的私有名称

* 整型/浮点型数字面值允许下划线 _ 进行分组

    `a = 100_000_000`

## 2. 数据模型

* 不可变对象

    * 数字（int，float，complex）

    * 字符串

    * 元组

* 可变对象

    * 列表

    * 集合

    * 字典

* 一个不可变容器对象如果包含对可变对象的引用，当后者的值改变时，前者的值也会改变；但是该容器仍属于不可变对象

* 实例化对象

    * class 中的 `__new__`和`__init__`是依次执行的

    * 如果 `__new__()` 返回一个 cls 的实例，则新实例的 `__init__()` 方法会在之后被执行，例如 `__init__(self[, ...])`，其中 self 为新实例，其余的参数与被传递给 `__new__()` 的相同。

    * 如果 `__new__()` 未返回一个 cls 的实例，则新实例的 `__init__()` 方法就不会被执行。

    * 单例模式

        ```
        class SingleInstance:
        def __new__(cls):
            if not hasattr(cls, "instance"):
                cls.instance = super().__new__(cls)
            return cls.instance
        ```